## 8.2 EXOGENOUS, OUT-PLACE TRANSFORMATIONS


ATLAS Transformation Language (ATL) is the chosen illustrative transformation language for developing exogenous, out-place transformations. It’s widely used in academia and industry, with mature tool support. ATL is a rule-based language that builds on OCL but provides dedicated features for model transformations missing in OCL, like creating model elements.

ATL, a hybrid model transformation language, combines declarative and imperative constructs. It’s *uni-directional*, requiring two transformations for language A to B and vice versa. ATL transformations operate on *read-only* source models and produce *write-only* target models. For out-place transformations, we use *source model* for *input model* and *target model* for *output model*.

During ATL transformations, source models are queried but not modified. Target model elements are created but not queried directly. These restrictions ensure that query results from source and target models remain consistent regardless of the transformation’s execution state, which contradicts the declarative nature of ATL.

<font style="color: #006ec7 ">Anatomy of ATL transformations.</font>  &emsp; An ATL transformation is represented as a *module* with a *header* and a *body* section. The header section specifies the module name and declares the source and target models, which are typed by their metamodels. ATL transformations can have multiple input and output models.

The ATL transformation body consists of *rules* and *helpers* stated in arbitrary order after the header section.

* **Rules**: Each rule describes how a part of the target model should be generated from a part of the source model. ATL has two kinds of declarative rules: *matched* rules and *lazy* rules. Matched rules are automatically matched by the ATL execution engine, while lazy rules require explicit calling from another rule, giving the transformation developer more control over the execution.

	Rules consist of *input* and *output* patterns. The input pattern filters source model elements relevant to the rule by defining input pattern elements. Each input pattern element requires an obligatory type (corresponding to a metaclass in the source metamodel) and an optional filter condition (expressed as an OCL expression). These constraints determine the applicable model elements. The output pattern details how the target model elements are created from the input. Each output pattern element can have multiple *bindings* to initialize the features of the target model elements. Binding values are calculated by OCL expressions.

* **Helpers**: A helper is an auxiliary function that enables the possibility of factoring ATL code used in different points of the transformation. There are two types of helpers: one simulates a derived attribute that needs to be accessible throughout the transformation, and the other represents an operation that calculates a value for a given context object and input parameters. Unlike rules, helpers cannot produce target model elements; they can only return values that are further processed within rules.

<font style="color: #006ec7 ">Execution phases of ATL transformations.</font>  &emsp; ATL, a powerful language, allows us to define transformations concisely. To understand its syntax, let’s examine the actual transformation execution by the ATL virtual machine. ATL transformations are executed in three sequential phases.




———






* ATLAS Transformation Language (ATL), a widely used rule-based transformation language, is chosen for developing exogenous transformations due to its mature tool support and features missing in OCL.


* ATL is a hybrid model transformation language with declarative and imperative constructs. It performs ***uni-directional*** transformations on ***read-only*** source models to produce ***write-only*** target models.

* During ATL transformations, source models are queried but not modified, while target models are created but not queried directly to maintain declarative consistency.

* An ATL transformation ***module*** consists of a ***header*** and ***body*** section. The header declares the transformation name, source, and target models, which can be multiple.

* ATL transformation body consists of ***rules*** and ***helpers***.

* ATL has two types of declarative rules: ***matched*** and ***lazy***. Matched rules are automatically executed, while lazy rules require explicit calls.

* Rules consist of ***input*** and ***output*** patterns. The input pattern filters source model elements using metaclass types and OCL expressions, while the output pattern defines target model elements and their feature initialization.

* Helpers in ATL code are auxiliary functions that factorize code and can simulate derived attributes or represent operations. They cannot produce target model elements.

* ATL transformation execution is structured into three sequential phases.