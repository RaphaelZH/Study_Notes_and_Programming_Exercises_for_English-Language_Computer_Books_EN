### 6.6.1 PRINCIPLES OF DSLS

DSLs are essential for many application scenarios, beyond software development. Designing a DSL requires deep domain knowledge and language engineering practices. Finding the right abstractions for defining a DSL is challenging and time-consuming.

To be useful, the DSL should follow these principles:

* The language should provide good abstractions, be intuitive, and simplify development, not complicate it.

* The language should be adopted and used by everyone, and its definition should be agreed upon after some evaluation, not just by one person.

* The language must evolve and be updated based on user and context needs to avoid extinction.

* Domain experts prioritize maximizing productivity in their domains, but they’re unwilling to invest significant time in defining methods and tools. Therefore, the language must be combined with supporting tools and methods.

* A good DSL should be open for extensions but closed for modifications, following the open-close principle that "software entities should be open for extension, but closed for modification."

Good DSLs don’t appear out of nowhere. MDSE aims to have good language designers who build suitable DSLs for the right audience. Refining a good language takes years, involving industrial experience and thousands of users. While DSL development is encouraged, careful design is essential. Defining a new DSL is not trivial and may lead to a language with weaknesses or drawbacks for future users. Tools, design interfaces, and runtime architectures should be tailored to the domain to avoid user rejection.

**Classification of DSLs**

DSLs can be classified based on focus, style, notation, internality, and execution.

**Focus**

DSLs can be vertical or horizontal. Vertical DSLs target specific industries or fields, like configuration languages for home automation, modeling languages for biological experiments, and analysis languages for financial applications. Horizontal DSLs have broader applicability and can apply to many applications. Examples include SQL, Flex, IFML, WebML, and more.

**Style**

DSLs can be declarative or imperative. Declarative DSLs express computation logic without describing control flow. They define what a program should accomplish, not how. Service choreography is a typical declarative definition, defining Web service coupling rules. Imperative DSLs require defining an executable algorithm with steps and control flow to complete a job. Service orchestration is a typical imperative definition, defining a start-to-end flow of execution between Web services.

**Notation**

DSLs can be graphical or textual. Graphical DSLs use visual models and graphical development primitives like blocks, arrows, edges, containers, and symbols. Textual DSLs include XML-based notations, structured text notations, and textual configuration files.

**Internality**

External DSLs, as defined by Martin Fowler, have their own custom syntax. You can write a full parser for them and use them to create self-standing, independent models and programs.

Internal DSLs extend a host language to mimic a specific domain or objective. This can be achieved by embedding DSL pieces in the host language or providing abstractions, structures, or functions. Embedding allows reuse of host language tools and facilities.

**Execution**

Executability can be implemented through model interpretation (reading and executing DSL scripts at runtime) or code generation (applying a complete model-to-text (M2T) transformation at deployment time).

> **Résumé** :
> 
> * DSLs require domain knowledge and language engineering practices for design.
> 
> * A useful DSL should provide good abstractions, be intuitive, and evolve based on user needs. It should be adopted by all, combined with supporting tools, and follow the open-close principle.
> 
> * Good DSLs require careful design, industrial experience, and thousands of users over years. Defining a new DSL is not trivial and should be tailored to the domain.
> 
> * DSLs are classified based on focus, style, notation, internality, and execution.
> 
>	 * **Focus** : DSLs can be vertical, targeting specific industries, or horizontal, with broader applicability. Examples include SQL, Flex, IFML, and WebML.
>	 
>	 * **Style**: DSLs can be declarative, defining what a program should accomplish, or imperative, defining an executable algorithm with steps and control flow.
>	 
>	 * **Notation**: DSLs can be graphical or textual, using visual models or structured text.
>	 
>	 * **Internality**: Internal DSLs extend a host language to mimic a domain, while external DSLs have their own custom syntax and can be used independently.
>	 
>	 * **Execution**: Executability can be implemented through model interpretation or code generation.